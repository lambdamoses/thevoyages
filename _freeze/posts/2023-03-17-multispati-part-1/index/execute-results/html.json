{
  "hash": "2ef139364259ec19e489b7b22d511318",
  "result": {
    "markdown": "---\ntitle: \"Spatially informed PCA\"\nauthor: \"Lambda Moses\"\ndate: \"2023-03-17\"\ncategories: [R, spatial-omics]\nbibliography: ../multispati.bib\n---\n\n\n# Introduction\nDue to the large number of genes quantified in single cell and spatial transcriptomics, dimension reduction is part of the standard workflow to analyze such data, to visualize, to help interpreting the data, to distill relevant information and reduce noise, to facilitate downstream analyses such as clustering and pseudotime, to project different samples into a shared latent space for data integration, and so on.\n\nThe first dimension reduction methods we learn about, such as good old principal component analysis (PCA), tSNE, and UMAP, don't use spatial information. With the rise of spatial transcriptomics, some dimension reduction methods that take spatial dependence into account have been written. Some, such as `SpatialPCA` [@Shang2022-qy], `NSF` [@Townes2023-bi], and `MEFISTO` [@Velten2022-gv] use factor analysis or probabilistic PCA which is related to factor analysis, and model the factors as Gaussian processes, with a spatial kernel for the covariance matrix, so the factors have positive spatial autocorrelation and can be used for downstream clustering where the clusters can be more spatially coherent. Some use graph convolution networks on a spatial neighborhood graph to find spatially informed embeddings of the cells, such as `conST` [@Zong2022-tb] and `SpaceFlow` [@Ren2022-qx]. `SpaSRL` [@Zhang2023-kf] finds a low dimension projection of spatial neighborhood augmented data. \n\nSpatially informed dimension reduction is actually not new, and dates back to at least 1985, with Wartenberg's crossover of Moran's I and PCA [@Wartenberg1985-fk], which was generalized and further developed as MULTISPATI PCA [@Dray2008-en], implemented in the [`adespatial`](https://cran.r-project.org/web/packages/adespatial/index.html) package on CRAN. In short, while PCA tries to maximize the variance explained by each PC, MULTISPATI maximizes the product of Moran's I and variance explained. Also, while all the eigenvalues from PCA are non-negative, because the covariance matrix is positive semidefinite, MULTISPATI can give negative eigenvalues, which represent negative spatial autocorrelation, which can be present and interesting but is not as common as positive spatial autocorrelation and is often masked by the latter [@Griffith2019-bo]. \n\nIn single cell -omics conventions, let $X$ denote a gene count matrix whose columns are cells or Visium spots and whose rows are genes, with $n$ columns. Let $W$ denote the row normalized $n\\times n$ adjacency matrix of the spatial neighborhood graph of the cells or Visium spots, which does not have to be symmetric. MULTISPATI diagonalizes a symmetric matrix\n\n$$\nH = \\frac 1 {2n} X(W^t+W)X^t\n$$\n\nHowever, the implementation in `adespatial` is more general and can be used for other multivariate analyses in the [duality diagram](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3265363/) paradigm, such as correspondence analysis; the equation above is simplified just for PCA, without having to introduce the duality diagram here.\n\nIn this blog post, I use `adespatial` to run MULTISPATI PCA, compare the results to those of non-spatial PCA, and in [Part 2](https://lambdamoses.github.io/thevoyages/posts/2023-03-19-multispati-part-2/) of the post, try a faster implementation using [`RSpectra`](https://cran.r-project.org/web/packages/RSpectra/index.html). The faster implementation will be added to the next release of `Voyager` in Bioconductor 3.17 in May. This will be the first multivariate spatial analysis method in `Voyager`, as the implementation is straightforward and all packages required are on CRAN or Bioconductor. This blog post itself will be edited to become a new vignette. I'm writing it here in the process to think before I code. **So the code here isn't meant to remain runnable in the future after the next release comes out, because the user interface of devel functions in Voyager can change in the next few weeks.**\n\nHere we load the packages:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ade4)\nlibrary(adespatial)\nlibrary(SFEData)\nlibrary(scater)\nlibrary(scran)\nlibrary(Voyager)\nlibrary(sparseMatrixStats)\nlibrary(SingleCellExperiment)\nlibrary(tidyverse)\nlibrary(bluster)\ntheme_set(theme_bw())\n```\n:::\n\n\nThe development version of `Voyager` is used here, and I will note code that doesn't work with the current release version in Bioconductor 3.16. In Bioconductor version numbering conventions, an odd minor version number (the second number) means devel.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npackageVersion(\"Voyager\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] '1.1.10'\n```\n:::\n:::\n\n\n# Preprocess data\n\nThe Visium dataset used here comes from mouse skeletal muscle 2 days after notexin injury, published in [@McKellar2021-ek]. Quality control and basic exploratory data analysis are shown in [`Voyager` vignettes](https://pachterlab.github.io/voyager/articles/vig1_visium_basic.html) so are not reproduced here.\n\nThe H&E image of this section:\n![A cross section of mouse muscle is slightly off center to the lower left. In the middle of the tissue is the notexin injury site with leukocyte infiltration and fewer myofibers. The rest of the tissue section is tightly packed with myofibers.](https://raw.githubusercontent.com/pachterlab/voyager/documentation/vignettes/tissue_lowres_5a.jpeg)\n\nHere we load the data into R:\n\n::: {.cell}\n\n```{.r .cell-code}\n(sfe <- McKellarMuscleData())\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nsnapshotDate(): 2022-10-31\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nsee ?SFEData and browseVignettes('SFEData') for documentation\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nloading from cache\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nrequire(\"SpatialFeatureExperiment\")\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nclass: SpatialFeatureExperiment \ndim: 15123 4992 \nmetadata(0):\nassays(1): counts\nrownames(15123): ENSMUSG00000025902 ENSMUSG00000096126 ...\n  ENSMUSG00000064368 ENSMUSG00000064370\nrowData names(6): Ensembl symbol ... vars cv2\ncolnames(4992): AAACAACGAATAGTTC AAACAAGTATCTCCCA ... TTGTTTGTATTACACG\n  TTGTTTGTGTAAATTC\ncolData names(12): barcode col ... prop_mito in_tissue\nreducedDimNames(0):\nmainExpName: NULL\naltExpNames(0):\nspatialCoords names(2) : imageX imageY\nimgData names(1): sample_id\n\nGeometries:\ncolGeometries: spotPoly (POLYGON) \nannotGeometries: tissueBoundary (POLYGON), myofiber_full (POLYGON), myofiber_simplified (POLYGON), nuclei (POLYGON), nuclei_centroid (POINT) \n\nGraphs:\nVis5A: \n```\n:::\n:::\n\n\nThe data includes spots that are not on tissue. We only use the spots that overlap with the tissue here:\n\n::: {.cell}\n\n```{.r .cell-code}\nsfe <- sfe[, sfe$in_tissue]\n```\n:::\n\n\nNormalize data and find highly variable genes with the `scran` method:\n\n::: {.cell}\n\n```{.r .cell-code}\nsfe <- logNormCounts(sfe)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndec <- modelGeneVar(sfe)\nhvgs <- getTopHVGs(dec, n = 2000)\n```\n:::\n\n\nGet the highly variable gene results for plotting:\n\n::: {.cell}\n\n```{.r .cell-code}\ndec$symbol <- rowData(sfe)[match(rownames(rowData(sfe)), rownames(dec)), \"symbol\"]\nfit_dec <- metadata(dec)\n```\n:::\n\n\nGet colorblind friendly palette\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(\"ditto_colors\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nas.data.frame(fit_dec[c(\"mean\", \"var\")]) |> \n    mutate(is_hvg = rownames(dec) %in% hvgs) |> \n    ggplot(aes(mean, var)) +\n    geom_point(aes(color = is_hvg), alpha = 0.3) +\n    geom_function(fun = fit_dec$trend, color = \"blue\") +\n    scale_color_manual(values = ditto_colors) +\n    labs(x = \"Mean of log counts\", y = \"Variance of log counts\",\n         color = \"Highly\\nvariable\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\nAccording to the [Orchestrating Single Cell Analysis with Bioconductor (OSCA)](https://bioconductor.org/books/3.16/OSCA.basic/feature-selection.html#quantifying-per-gene-variation) book, the log transformed values are used so Euclidean distances represent log fold changes, so genes with 100 counts in one cell type and 50 in another would be more emphasized than genes with 1100 counts in one cell type and 1000 in another. Most of the variation in gene expression is assumed to be technical and uninteresting biological variation, modeled by the curve fitted to the variance vs. mean plot. Highly variable genes have more variance than explained by that curve. Here we see that after log normalization, the highly variable genes have a wide range of levels of expression. Since `scran` uses log2 so differences in values can be interpreted as fold change and the scale factors are centered at 1 so the log normalized values can be more readily transformed back to original counts ($x$ in log transformed value would be roughly $2^x$ in counts), the range we see here is from nearly 0 to maybe 256. Here's the range of expression levels of highly variable genes in raw counts:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhvg_means <- rowMeans(counts(sfe)[hvgs,])\nsummary(hvg_means)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. \n  0.0011   0.1084   0.2141   1.2462   0.4802 356.0225 \n```\n:::\n:::\n\n\nWhat are the most highly expressed highly variable genes?\n\n::: {.cell}\n\n```{.r .cell-code}\nrowData(sfe)[hvgs[order(hvg_means, decreasing = TRUE)[1:10]], \"symbol\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"mt-Co1\"  \"Myh4\"    \"mt-Nd4\"  \"mt-Nd2\"  \"mt-Cytb\" \"mt-Nd3\"  \"Tnnc2\"  \n [8] \"Tpm1\"    \"Tnni2\"   \"Myl1\"   \n```\n:::\n:::\n\n\nThese mitochondrial and skeletal muscle genes, which is not surprising given that this is a skeletal muscle dataset. Tnnc2 is troponin C2, fast skeletal type. Tpm1 is tropomyosin 1. Myh4 is myosin heavy chain 4. Tnni2 is troponin I2, fast skeletal type. Myl1 is myosin light chain 1.\n\nWhat are the least highly expressed highly variable genes?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrowData(sfe)[hvgs[order(hvg_means)[1:10]], \"symbol\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"Gm25099\"       \"1700088E04Rik\" \"Dixdc1\"        \"Tesc\"         \n [5] \"Gldn\"          \"Ndnf\"          \"Gm13012\"       \"Kif13b\"       \n [9] \"Tmem255b\"      \"2310058D17Rik\"\n```\n:::\n:::\n\n\nSome unannotated and less studied genes.\n\nWhat are the highly variable genes with the largest \"biological\" component?\n\n::: {.cell}\n\n```{.r .cell-code}\nrownames(dec) <- NULL\nhead(dec[order(dec$bio, decreasing = TRUE), ], 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDataFrame with 10 rows and 7 columns\n        mean     total      tech       bio     p.value         FDR      symbol\n   <numeric> <numeric> <numeric> <numeric>   <numeric>   <numeric> <character>\n1    2.29638   4.01867   1.22416   2.79451 2.01788e-44 1.01183e-40        Spp1\n2    2.71027   3.50818   1.27105   2.23712 3.23763e-27 4.05864e-24        Ftl1\n3    2.21783   3.37962   1.21788   2.16174 1.20002e-27 1.64108e-24      Lgals3\n4    3.22352   3.20809   1.29231   1.91578 7.31366e-20 5.00088e-17        Ctsb\n5    2.12640   2.80889   1.21147   1.59742 4.22693e-16 1.98705e-13        Lgmn\n6    2.29238   2.77378   1.22392   1.54987 5.44090e-15 2.33850e-12          Mb\n7    3.56296   2.74445   1.25213   1.49232 1.74706e-13 5.47520e-11        Psap\n8    3.67225   2.69356   1.24358   1.44998 5.55292e-13 1.60640e-10        Myh1\n9    2.73703   2.72133   1.27389   1.44744 2.03761e-12 5.37751e-10         B2m\n10   3.36722   2.70455   1.27026   1.43429 2.76503e-12 6.80421e-10        Actb\n```\n:::\n:::\n\n\nThey are not the most highly expressed genes, but still much more expressed than most other highly variable genes.\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(fit_dec$mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n0.00000 0.01001 0.05144 0.16140 0.14853 8.06119 \n```\n:::\n:::\n\n\nHere we run non-spatial PCA. To scale or not to scale? This is relevant to both spatial and non-spatial PCA. In Seurat, the log normalized data is scaled, or standardized, so the mean is 0 and variance is 1, before PCA. The purpose of scaling before PCA is that when different variables are measured in different units or different scales, scaling the data will prevent the variables with much larger values due to the units to dominate the variance simply because of the units. \n\nIf we don't want genes with higher expression and thus higher variance to dominate the principal components simply because they tend to be more highly expressed across all cells or spots, and if the absolute level of expression itself is not of interest, then scaling would make sense. While log transform pulls the very long tail in, more highly expressed genes still have much larger values than less expressed genes. Given the wide range (though much wider before log transform) of values, scaling makes sense if all highly variable genes are deemed important. The less expressed genes may give more nuances not expected from the very highly expressed genes characteristic of the tissue and already well-studied. So I scale the data here.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstart <- Sys.time()\nsfe <- runPCA(sfe, ncomponents = 30, subset_row = hvgs, scale = TRUE)\n(pca_time <- Sys.time() - start)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTime difference of 0.7611551 secs\n```\n:::\n:::\n\n\nHere we plot the results: variance explained by each PC\n\n::: {.cell}\n\n```{.r .cell-code}\nElbowPlot(sfe)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n\nTop gene loadings for each PC\n\n::: {.cell}\n\n```{.r .cell-code}\nplotDimLoadings(sfe, swap_rownames = \"symbol\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\nPlotting spot embeddings in each PC in histological space\n\n::: {.cell}\n\n```{.r .cell-code}\nspatialReducedDim(sfe, \"PCA\", 8, divergent = TRUE, diverge_center = 0,\n                  ncol = 4)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-18-1.png){width=864}\n:::\n:::\n\n\nPC1 separates myofibers from the leukocyte filtrated injury site. PC2 and PC3 separate muscle tendon junctions from the rest of the tissue but PC2 also picks up more on the edges of the regions with myofibers while PC3 has more emphasis on the muscle tendon junctions. PC4 and after seem to pick up outliers. While spatial information is not used to compute PCA here, PCs 1-3 do exhibit spatial structure, because different cell types are located in different regions in this tissue.\n\n# MULTISPATI PCA\nHere I use the `adespatial` implementation of MULTISPATI to perform spatial PCA and time the execution.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstart <- Sys.time()\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncolGraph(sfe, \"visium\") <- findVisiumGraph(sfe)\n```\n:::\n\n\nFirst I need to convert the data into a data frame.\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- logcounts(sfe)[hvgs,] |> \n    as.matrix() |> t() |> \n    as.data.frame()\n```\n:::\n\n\nBy default, the `ade4::dudi.pca()` function centers and scales the data. The \"dudi\" in the name means duality diagram, the philosophy of the `ade4` and `adespatial` packages.\n\n::: {.cell}\n\n```{.r .cell-code}\npca <- dudi.pca(df, scannf = FALSE, nf = 30)\n```\n:::\n\n\nHere I get 30 top positive and 30 top negative PCs.\n\n::: {.cell}\n\n```{.r .cell-code}\nmultispati_res <- multispati(pca, colGraph(sfe, \"visium\"), scannf = FALSE,\n                             nfposi = 30, nfnega = 30)\n```\n:::\n\n\nReformat and add the results to the SFE object:\n\n::: {.cell}\n\n```{.r .cell-code}\nmultispati_mat <- multispati_res$li\nrownames(multispati_mat) <- colnames(sfe)\nloadings <- multispati_res$c1\nrownames(loadings) <- hvgs\ncolnames(loadings) <- str_replace(colnames(loadings), \"CS\", \"PC\")\nattr(multispati_mat, \"rotation\") <- loadings\nreducedDim(sfe, \"multispati\") <- multispati_mat\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nSys.time() - start\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTime difference of 29.61663 secs\n```\n:::\n:::\n\n\nThat may not seem too bad at first sight, even with R's non-optimized BLAS, although all eigenvalues are computed while most are not saved to the results. There are only 900 something spots and 2000 highly variable genes in this dataset. My laptop will run out of RAM when there are 100,000 cells, such as in the CosMX and Xenium datasets in `SFEData`, because according to this [awesome benchmark of PCA methods in R](https://slowkow.com/notes/pca-benchmark/), base R's `prcomp` uses 42 GB of RAM for 100,000 cells, which my laptop doesn't have. \n\nIn addition, the eigen decomposition is done twice here. First in `dudi.pca()`, computing the full spectrum, from which `multispati()` grabs the original data and the duality diagram column and row weights but not the PCA results. Second in `multispati()` where we find all eigenvalues and eigenvectors of a different matrix with the spatial weights. This is very inefficient because a lot of unnecessary work is done. I'll write a faster implementation with `RSpectra`; while unlike non-spatial PCA, MULTISPATI can't be simply converted to singular value decomposition (SVD), `RSpectra` has an efficient algorithm to only find a small number of eigenvectors with the largest or smallest $k$ eigenvalues. Furthermore, `RSpectra` natively supports sparse matrix so I don't have to convert the data into dense matrix and then data frame as I have done just now. \n\nIn contrast, finding 30 non-spatial PCs with `Irlba` in the previous section only took about 0.761 seconds; IRLBA is an approximate SVD method, and only 30 instead of 900 something PCs were computed.\n\nNow look at the results:\nThe eigenvalues can be negative.\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(multispati_res$eig, type = \"l\", main = \"Eigenvalues of MULTISPATI\", ylab = NA)\nabline(h = 0, lty = 2)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-26-1.png){width=672}\n:::\n:::\n\n\nThe top positive eigenvalues are much larger in magnitude than the top (or bottom?) negative ones. Here I got the eigenvectors and spot embeddings with the top 30 positive and negative eigenvalues. To better show a negative elbow plot not dwarfed by the positive one:\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(tail(multispati_res$eig, 30), type = \"l\", main = \"Eigenvalues of MULTISPATI\", ylab = NA)\nabline(h = 0, lty = 2)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-27-1.png){width=672}\n:::\n:::\n\n\nReading this plot in the opposite direction from the regular PCA elbow plot: there's an elbow at the 3rd to last component. Then the eigenvalues increase steadily.\n\nHow do the top positive eigenvalues compare to those of non-spatial PCA?\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_eigs <- data.frame(PCA = pca$eig[1:10],\n                      MULTISPATI = multispati_res$eig[1:10],\n                      index = 1:10)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_eigs |> \n    pivot_longer(-index, names_to = \"name\", values_to = \"value\") |> \n    ggplot(aes(index, value, color = name)) +\n    geom_line() +\n    scale_color_manual(values = ditto_colors) +\n    scale_x_continuous(breaks = scales::breaks_width(2)) +\n    labs(y = \"Eigenvalue\", color = \"Type\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-29-1.png){width=672}\n:::\n:::\n\n\nThere's the similar sharp drop from PC1 to PC2, and MULTISPATI eigenvalues tend to be smaller than their non-spatial PCA counterparts. In non-spatial PCA, the eigenvalue is variance explained by each PC, but this does not hold for MULTISPATI. So here I compare the actual variance of the MULTISPATI embeddings with the non-spatial PCA eigenvalues:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- ncol(sfe)\ndf_eigs2 <- data.frame(PCA = attr(reducedDim(sfe, \"PCA\"), \"percentVar\")[1:10]/100,\n                       MULTISPATI = colVars(as.matrix(multispati_mat[,1:10])) / \n                           sum(pca$eig),\n                       index = 1:10)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_eigs2 |> \n    pivot_longer(-index, names_to = \"name\", values_to = \"value\") |> \n    ggplot(aes(index, value, color = name)) +\n    geom_line() +\n    scale_color_manual(values = ditto_colors) +\n    scale_x_continuous(breaks = scales::breaks_width(2)) +\n    scale_y_continuous(labels = scales::percent) +\n    labs(y = \"Percentage of variance explained\", color = \"Type\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-31-1.png){width=672}\n:::\n:::\n\n\nThe loss of variance explained in MULTISPATI due to accounting for Moran's I is small for the first 2 PCs. For the later PCs, MULTISPATI can still explain the majority of the amount of variance explained by the non-spatial PCs. Plot the genes with top loadings in the top 2 positive and negative PCs:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplotDimLoadings(sfe, dims = c(1:2, 932:933), reduction = \"multispati\",\n                swap_rownames = \"symbol\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-32-1.png){width=672}\n:::\n:::\n\n\nHere we plot the 4 spatial PCs with the most positive eigenvalues and 4 PCs with the most negative eigenvalues. Here CS1 looks similar to PC1, but the other components look different from their non-spatial counterparts.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspatialReducedDim(sfe, \"multispati\", ncomponents = 8, \n                  divergent = TRUE, diverge_center = 0, ncol = 4)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-33-1.png){width=864}\n:::\n:::\n\n\nWhat do these components mean? Each component is a linear combination of genes to maximize the product of variance explained and Moran's I. The second component maximizes this product provided that it's orthogonal to the first component, and so on. As the loss in variance explained isn't huge, these components can be considered axes along which _spatially coherent_ groups of spots are separated from each other as much as possible according to expression of the highly variable genes, so in theory, clustering with positive MULTISPATI components should give more spatially coherent clusters. Because of the spatial coherence, MULTISPATI might be more robust to outliers.\n\nAlso, it seems that the subsequent components highlight smaller spatial regions than PC1 and PC2, so potentially, by choosing different components, spatial regions of different scales can be discovered. Here we confirm this with a Moran's I correlogram:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsfe <- reducedDimUnivariate(sfe, \"sp.correlogram\", dimred = \"multispati\",\n                            components = 1:8, order = 5)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplotCorrelogram(sfe, features = paste0(\"CS\", 1:8), reducedDimName = \"multispati\") +\n    scale_color_viridis_d(end = 0.9, option = \"E\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-35-1.png){width=672}\n:::\n:::\n\n\nIn Visium's regular hexagonal grid, orders of neighbors -- i.e. second order means neighbors of neighbors and 3rd order means neighbors of neighbors of neighbors -- are a proxy of distance. Indeed, spatial autocorrelation, as measured by Moran's I, tends to decay over shorter distance for the \"later\" components.\n\nNext plot the projection of each spot on the top negative components:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspatialReducedDim(sfe, \"multispati\", ncomponents = 53:60, \n                  divergent = TRUE, diverge_center = 0, ncol = 4)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-36-1.png){width=864}\n:::\n:::\n\n\nThe components with negative eigenvalues tend to highlight the leukocyte infiltrated region and the edge of the muscle. How shall they be interpreted? The component with the most negative eigenvalue minimizes the product of variance explained and Moran's I. Because the eigenvalues can be negative while variance can't be negative, a larger variance explained coupled with a more negative Moran's I will make the product more negative, hence minimizing it. So these negative components can shed light on local spatial heterogeneity, perhaps caused by local competition or colocalization of different cell types whose differences contribute to tissue function, such as myofibers and satellite cells in the skeletal muscle, and hepatocytes and Kupffer cells in the liver. Here we plot percentage of variance explained by the top negative components:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninds <- tail(1:ncol(multispati_mat), 30)\ndf_neg <- data.frame(\n    percentVar = colVars(as.matrix(multispati_mat[, inds])) / sum(pca$eig),\n    index = inds)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(df_neg, aes(index, percentVar)) +\n    geom_line() +\n    scale_x_continuous(breaks = scales::breaks_width(5)) +\n    scale_y_continuous(labels = scales::percent) +\n    labs(y = \"Percentage variance explained\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-38-1.png){width=672}\n:::\n:::\n\n\nIn this dataset, the percentage of variance explained by each of the top negative components is minuscule, around 0.3%, and is higher for components with more negative eigenvalues. However, this might not be so minuscule for some other datasets with single cell resolution, which I'll look at in Part 2, to see how relevant negative spatial autocorrelation is to spatial transcriptomics. But we are looking at the global variance here, which can be diminished because most spots take homogeneous values while some smaller regions are very heterogeneous. The new spatially informed dimension reduction methods using Gaussian process all impose positive spatial autocorrelation on the factors or components, which can be problematic if negative spatial autocorrelation is relevant to some tissues. \n\nHowever, negative spatial autocorrelation at the scale of Visium spots does not seem very relevant to this particular dataset, possibly due to the lower spatial resolution averaging out some local competitions and heterogeneity at the single cell level. Or maybe while individual negative components don't seem to matter, they collectively matter.\n\n## Moran's I of MULTISPATI and non-spatial PCA embeddings\n\nHere we compute Moran's I for the spot embeddings. Note that this is a devel feature, not implemented in the Bioconductor 3.16 version of Voyager, and might change before the release of Bioconductor 3.17.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# non-spatial\nsfe <- reducedDimMoransI(sfe, dimred = \"PCA\", components = 1:30)\n# spatial\nsfe <- reducedDimMoransI(sfe, dimred = \"multispati\", components = 1:60)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_moran <- tibble(PCA = reducedDimFeatureData(sfe, \"PCA\")$moran_Vis5A[1:30],\n                   MULTISPATI_pos = reducedDimFeatureData(sfe, \"multispati\")$moran_Vis5A[1:30],\n                   MULTISPATI_neg = reducedDimFeatureData(sfe,\"multispati\")$moran_Vis5A[31:60] |> \n                       rev(),\n                   index = 1:30)\n```\n:::\n\n\nThe lower bound of Moran's I given the spatial neighborhood graph is usually greater than -1, while the upper bound is usually around 1. The bounds given this particular spatial neighborhood graph can be found here:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(mb <- moran.bounds(colGraph(sfe, \"visium\")))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      Imin       Imax \n-0.5762132  1.0021884 \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_moran |> \n    pivot_longer(cols = -index, values_to = \"value\", names_to = \"name\") |> \n    ggplot(aes(index, value, color = name)) +\n    geom_line() +\n    scale_color_manual(values = ditto_colors) +\n    geom_hline(yintercept = 0) +\n    geom_hline(yintercept = mb, linetype = 2) +\n    scale_y_continuous(breaks = scales::breaks_pretty()) +\n    scale_x_continuous(breaks = scales::breaks_width(5)) +\n    labs(y = \"Moran's I\", color = \"Type\", x = \"Component\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-42-1.png){width=672}\n:::\n:::\n\n\nMULTISPATI's PCs do have higher Moran's I than those of non-spatial PCA, when the eigenvalues are positive. The difference is much larger after the first 2 PCs. Moran's I drops quickly towards 0 as we move on to the subsequent non-spatial PCs, while the decay is much more gradual for MULTISPATI. The negative Moran's I's for the components with the most negative eigenvalues are actually very strong considering the bounds (shown in dashed horizontal lines).\n\n# Clustering with MULTISPATI PCA\n\nIn the standard scRNA-seq data analysis workflow, a k nearest neighbor graph is found in the PCA space, which is then used for graph based clustering such as Louvain and Leiden, which is used to perform differential expression. Spatial dimension reductions can similarly be used to perform clustering, to identify spatial regions in the tissue, as done in [@Shang2022-qy; @Ren2022-qx; @Zhang2023-kf]. This type of studies often use a manual segmentation as ground truth to compare different methods that identify spatial regions. \n\nThe problem with this is that spatial region methods are meant to help us to identify novel spatial regions based on new -omics data, which might reveal what's previously unknown from manual annotations. If the output from a method doesn't match manual annotations, it might simply be pointing out a previously unknown aspect of the tissue rather than wrong. Depending on the questions being asked, there can simultaneously be multiple spatial partitions. This happens in geographical space, which I'll elaborate on in a future blog post. For instance, there's land use and neighborhood boundaries, but equally valid are watershed boundaries and types of rock formation. Which one is relevant depends on the questions asked.\n\nHere we perform Leiden clustering with non-spatial and MULTISPATI PCA and compare the results. For the k nearest neighbor graph, I used the default k = 10.\n\n## Clustering with non-spatial PCA\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(29)\nsfe$clusts_nonspatial <- clusterCells(sfe, use.dimred = \"PCA\", \n                                      BLUSPARAM = NNGraphParam(\n                                          cluster.fun = \"leiden\",\n                                          cluster.args = list(\n                                              objective_function = \"modularity\",\n                                              resolution_parameter = 1\n                                          )\n                                      ))\n```\n:::\n\n\nColor the PCA scatter plot with the clusters:\n\n::: {.cell}\n\n```{.r .cell-code}\nplotPCA(sfe, ncomponents = 3, colour_by = \"clusts_nonspatial\") +\n    scale_color_manual(values = ditto_colors)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-44-1.png){width=672}\n:::\n:::\n\n\nPlot the clusters in space:\n\n::: {.cell}\n\n```{.r .cell-code}\nplotSpatialFeature(sfe, \"clusts_nonspatial\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-45-1.png){width=672}\n:::\n:::\n\n\nClusters 1, 3, 5, 6, 7 are myofibers, while 2 and 4 are in the leukocyte infiltrated injury region. Cluster 6 may be related to the muscle tendon junction, based on location. We use the silhouette index to score how well separated the clusters are in histological space:\n\n::: {.cell}\n\n```{.r .cell-code}\nsil <- approxSilhouette(spatialCoords(sfe), clusters = sfe$clusts_nonspatial)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(sil$width)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -0.009435808\n```\n:::\n:::\n\n\nA positive number closer to 1 indicates that the clusters are well-separated. Here the number is close to 0 and is negative, which means that the clusters are not well-separated in space and many spots are closer to spots from other clusters than those from its own cluster, as in the visual impression.\n\n## With MULTISPATI PCA\n\nHere we use the top positive MULTISPATI PCs for clustering, with the same Leiden parameters.\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(29)\nsfe$clusts_multispati <- clusterRows(reducedDim(sfe, \"multispati\")[,1:30],\n                                     BLUSPARAM = NNGraphParam(\n                                          cluster.fun = \"leiden\",\n                                          cluster.args = list(\n                                              objective_function = \"modularity\",\n                                              resolution_parameter = 1\n                                          )\n                                      ))\n```\n:::\n\n\nColor MULTISPATI scatter plot with the clusters:\n\n::: {.cell}\n\n```{.r .cell-code}\nplotReducedDim(sfe, \"multispati\", ncomponents = 3, colour_by = \"clusts_multispati\") +\n    scale_color_manual(values = ditto_colors)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-49-1.png){width=672}\n:::\n:::\n\n\nThe shapes of the scatter plots look similar to those in non-spatial PCA, at least for the first 3 PCs.\n\nColor the MULTISPATI scatter plot with non-spatial PCA clustering:\n\n::: {.cell}\n\n```{.r .cell-code}\nplotReducedDim(sfe, \"multispati\", ncomponents = 3, colour_by = \"clusts_nonspatial\") +\n    scale_color_manual(values = ditto_colors)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-50-1.png){width=672}\n:::\n:::\n\n\nThe clusters seem similar except for the numbering. \n\nPlot the MULTISPATI clusters in space, side by side with the non-spatial ones:\n\n::: {.cell}\n\n```{.r .cell-code}\np1 <- plotSpatialFeature(sfe, \"clusts_multispati\") +\n    ggtitle(\"MULTISPATI\")\np2 <- plotSpatialFeature(sfe, \"clusts_nonspatial\") +\n    ggtitle(\"Non-spatial PCA\")\np1 + p2\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-51-1.png){width=768}\n:::\n:::\n\n\nMULTISPATI clusters (left) do appear more spatially coherent than non-spatial PCA clustering (right). Also compute the silhouette index here:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsil2 <- approxSilhouette(spatialCoords(sfe), clusters = sfe$clusts_multispati)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(sil2$width)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.07191857\n```\n:::\n:::\n\n\nWhile it's not a very high value because there's only so much that can fit into 2 dimensions, it indicates that the MULTISPATI clusters are better separated in histological space than non-spatial PCA clusters.\n\nWhat do these clusters mean? Clusters are supposed to be groups of different spots that are more similar within a group, sharing some characteristics. Non-spatial and MULTISPATI PCA use different characteristics for the clustering. Non-spatial PCA finds genes that are good for telling cell types apart, although those genes may happen to be very spatially structured. Non-spatial clustering aims to find these groups only from gene expression, and cells with similar gene expression can be surrounded by cells of other types in histological space. This is just like mapping Art Deco buildings, which are often near Spanish revival and Beaux Art buildings whose styles are quite different and perform different functions, thus not necessarily forming a coherent spatial region. \n\nIn contrast, MULTISPATI's positive components find genes that must characterize spatial regions in addition to distinguishing between different cell types. Which genes are involved in each MULTISPATI component may be as interesting as the clusters. It would be interesting to perform gene set enrichment analysis, or to interpret this as some sort of spatial patterns of spatially variable genes. This is like mapping when the buildings were built, so Art Deco, Spanish revival, Beaux Art popular in the 1920s and 1930s will end up in the same cluster and form a more spatially coherent region, which can be found in DTLA Historical Core and Jewelry District, and Old Pasadena. Hence non-spatial clustering of spatial data isn't necessarily bad. Rather, it tells a different story and reveals different aspects of the data from spatial clustering. \n\n## Smaller scale clusters\nSpatial regions can come in hierarchies. In geographical space, using an example familiar to me from the voyages of starship Voyager, this can be Southern California (SoCal) at a higher level, defined by culture and climate, followed by the metropolitan region of LA and Orange Counties (OC) and perhaps urgan regions of western San Bernardino County, followed by different regions of LA County such as Eastside, Westside, South Bay, Harbor Cities, South LA, Central LA, San Fernando Valley (SFV), Northeast LA, San Gabriel Valley (SGV), Pomona Valley, Angeles National Forest, Antelope Valley, Santa Monica Mountains, and etc., followed by neighborhoods and small cities within those regions, such as Boyle Heights, Highland Park, Mt Washington, Westwood, and etc. which in practice are similar in scale and function to most smaller cities like San Marino, Beverly Hills, Culver City, Arcadia, San Gabriel, and etc., each of which have sub-regions. \n\nSuppose we perform MULTISPATI PCA on LA County, not really quantitatively, just based on my own familiarity and types of interactions with these places. I think PC1 would separate the wilderness of Angeles National Forest, Santa Monica Mountains, Griffith Park, much of San Rafael Hills, and much of Puente hills from the urban and suburban regions. PC2 might separate the mostly Black and Hispanic regions that are usually less affluent such as Eastside, South LA, and NELA, from affluent mostly White and sometimes Asian regions like Westside, South Bay, Beverly Hills, southern SFV, northern SGV, La Canada Flintridge, and etc. but it might not distinguish between different Latino regions such as Highland Park and El Sereno. PC2 and PC3 may also pick up the Asian regions in much of the SGV and in Koreatown. Subsequent PCs may pick up some industrial regions, such as Arts District, Vernon, City of Industry, Carson, Wilmington, and perhaps smaller racialized regions, such as those within Pasadena and DTLA, different vibes of neighborhoods with similar socioeconomic status, mini-downtowns of neighborhoods, smaller but very distinct regions such as the Aerospace Corridor near LAX, and architectural styles from different eras. \n\nClustering with the first few PCs will give you Angeles National Forest, Eastside, Westside, and etc., which might not answer a specific question about LA, such as different types of Latino neighborhoods, redistricting Pasadena, and different ecosystems within the Angeles National Forest. These questions would benefit from the \"later\" PCs with smaller length scales of spatial autocorrelation. Another moral of this thought experiment is that the PCs that explain a smaller percentage of variance aren't necessarily uninteresting. That something else shows a more drastic difference doesn't mean that smaller differences are irrelevant. I personally find these more local differences very interesting. However, those unfamiliar with the region won't ask these questions to begin with. Moral: as a bioinformatician not specialized in any particular tissue or disease, each of which seems to be its own field of study, I desperately need the help of experts in those tissues and diseases to make sense of data. I might not be using the most relevant way to find spatial regions when it comes to the more relevant questions about those tissues and diseases. \n\nAnyway, biological interpretations aside, what if we cluster with MULTISPATI components with shorter length scales of spatial autocorrelation?\n\nFirst, what do those components look like?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspatialReducedDim(sfe, \"multispati\", ncomponents = 9:30, \n                  divergent = TRUE, diverge_center = 0, ncol = 6)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-54-1.png){width=1152}\n:::\n:::\n\n\nAlso plot top gene loadings for some of these MULTISPATI components:\n\n::: {.cell}\n\n```{.r .cell-code}\nplotDimLoadings(sfe, dims = 8:13, reduction = \"multispati\", \n                swap_rownames = \"symbol\", ncol = 3)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-55-1.png){width=672}\n:::\n:::\n\n\nSome genes with high loading in these \"later\" components are known to be involved in muscle regeneration, such as Myog, Xirp1, and Cxcl9, and potentially Bicd2, Csrp3, and Nek6. The [`slingshot`](https://bioconductor.org/packages/release/bioc/html/slingshot.html) package performs pseudotime analysis on any dimension reduction. It would be interesting to see what if we perform pseudotime analysis on MULTISPATI rather than non-spatial PCA, with the later two timepoints and more biological replica. This dataset comes from the first time point after notexin injury, and this study only has one biological replicate per time point.\n\nThese components tend to highlight heterogeneity within the leukocyte infiltrated injury region when plotting the embeddings in space, which is consistent with the muscle regeneration genes with high. This seems to be the case, based on visual inspection, for CS8 and later. What if I only use CS8 and later components for clustering?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(29)\nsfe$clusts_multispati2 <- clusterRows(reducedDim(sfe, \"multispati\")[,8:30],\n                                     BLUSPARAM = NNGraphParam(\n                                          cluster.fun = \"leiden\",\n                                          cluster.args = list(\n                                              objective_function = \"modularity\",\n                                              resolution_parameter = 1\n                                          )\n                                      ))\n```\n:::\n\n\nHere's the H&E image for reference:\n![](https://raw.githubusercontent.com/pachterlab/voyager/documentation/vignettes/tissue_lowres_5a.jpeg)\n\n\n::: {.cell}\n\n```{.r .cell-code}\np1 <- plotSpatialFeature(sfe, \"clusts_multispati2\") +\n    ggtitle(\"CS8-30\")\np2 <- plotSpatialFeature(sfe, \"clusts_multispati\") +\n    ggtitle(\"CS1-30\")\np1 + p2\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-57-1.png){width=768}\n:::\n:::\n\n\nIt seems that when using all of the top 30 PCs from MULTISPATI, while PC1 by far explains much more variance than other PCs, the heterogeneity from the later PCs is not all overwhelmed and lost. When using only 8-30, perhaps due to the shorter length scale of spatial autocorrelation, the clusters are less spatially contiguous, and there are smaller, more local clusters such as clusters 5 and 6 that might mark distinct muscle regions adjacent to the injury region. \n\n# Session info\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessionInfo()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.2.2 (2022-10-31)\nPlatform: x86_64-apple-darwin17.0 (64-bit)\nRunning under: macOS Big Sur ... 10.16\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.2/Resources/lib/libRblas.0.dylib\nLAPACK: /Library/Frameworks/R.framework/Versions/4.2/Resources/lib/libRlapack.dylib\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\nattached base packages:\n[1] stats4    stats     graphics  grDevices utils     datasets  methods  \n[8] base     \n\nother attached packages:\n [1] SpatialFeatureExperiment_1.1.5 bluster_1.8.0                 \n [3] lubridate_1.9.2                forcats_1.0.0                 \n [5] stringr_1.5.0                  dplyr_1.1.0                   \n [7] purrr_1.0.1                    readr_2.1.4                   \n [9] tidyr_1.3.0                    tibble_3.1.8                  \n[11] tidyverse_2.0.0                sparseMatrixStats_1.10.0      \n[13] Voyager_1.1.10                 scran_1.26.2                  \n[15] scater_1.27.6                  ggplot2_3.4.1                 \n[17] scuttle_1.8.4                  SingleCellExperiment_1.20.0   \n[19] SummarizedExperiment_1.28.0    Biobase_2.58.0                \n[21] GenomicRanges_1.50.2           GenomeInfoDb_1.34.9           \n[23] IRanges_2.32.0                 S4Vectors_0.36.1              \n[25] BiocGenerics_0.44.0            MatrixGenerics_1.10.0         \n[27] matrixStats_0.63.0             SFEData_1.0.2                 \n[29] adespatial_0.3-20              ade4_1.7-22                   \n\nloaded via a namespace (and not attached):\n  [1] utf8_1.2.3                    R.utils_2.12.2               \n  [3] tidyselect_1.2.0              RSQLite_2.3.0                \n  [5] AnnotationDbi_1.60.0          htmlwidgets_1.6.1            \n  [7] grid_4.2.2                    BiocParallel_1.32.5          \n  [9] RNeXML_2.4.11                 DropletUtils_1.18.1          \n [11] munsell_0.5.0                 ScaledMatrix_1.6.0           \n [13] codetools_0.2-19              units_0.8-1                  \n [15] interp_1.1-3                  statmod_1.5.0                \n [17] withr_2.5.0                   colorspace_2.1-0             \n [19] filelock_1.0.2                knitr_1.42                   \n [21] uuid_1.1-0                    rstudioapi_0.14              \n [23] wk_0.7.1                      labeling_0.4.2               \n [25] GenomeInfoDbData_1.2.9        farver_2.1.1                 \n [27] bit64_4.0.5                   rhdf5_2.42.0                 \n [29] vctrs_0.5.2                   generics_0.1.3               \n [31] xfun_0.37                     timechange_0.2.0             \n [33] BiocFileCache_2.6.1           adegenet_2.1.10              \n [35] adephylo_1.1-13               R6_2.5.1                     \n [37] ggbeeswarm_0.7.1              rsvd_1.0.5                   \n [39] locfit_1.5-9.7                bitops_1.0-7                 \n [41] rhdf5filters_1.10.0           cachem_1.0.7                 \n [43] DelayedArray_0.24.0           promises_1.2.0.1             \n [45] scales_1.2.1                  beeswarm_0.4.0               \n [47] gtable_0.3.1                  phylobase_0.8.10             \n [49] beachmat_2.14.0               rlang_1.0.6                  \n [51] splines_4.2.2                 scico_1.3.1                  \n [53] BiocManager_1.30.20           s2_1.1.2                     \n [55] yaml_2.3.7                    reshape2_1.4.4               \n [57] httpuv_1.6.9                  tools_4.2.2                  \n [59] spData_2.2.2                  SpatialExperiment_1.8.0      \n [61] ellipsis_0.3.2                RColorBrewer_1.1-3           \n [63] proxy_0.4-27                  Rcpp_1.0.10                  \n [65] plyr_1.8.8                    progress_1.2.2               \n [67] zlibbioc_1.44.0               classInt_0.4-9               \n [69] RCurl_1.98-1.10               prettyunits_1.1.1            \n [71] dbscan_1.1-11                 deldir_1.0-6                 \n [73] viridis_0.6.2                 ggrepel_0.9.3                \n [75] cluster_2.1.4                 magrittr_2.0.3               \n [77] magick_2.7.3                  ggnewscale_0.4.8             \n [79] patchwork_1.1.2               hms_1.1.2                    \n [81] mime_0.12                     evaluate_0.20                \n [83] xtable_1.8-4                  XML_3.99-0.13                \n [85] jpeg_0.1-10                   gridExtra_2.3                \n [87] compiler_4.2.2                KernSmooth_2.23-20           \n [89] crayon_1.5.2                  R.oo_1.25.0                  \n [91] htmltools_0.5.4               tzdb_0.3.0                   \n [93] mgcv_1.8-41                   later_1.3.0                  \n [95] spdep_1.2-8                   DBI_1.1.3                    \n [97] ExperimentHub_2.6.0           dbplyr_2.3.1                 \n [99] MASS_7.3-58.2                 rappdirs_0.3.3               \n[101] sf_1.0-9                      boot_1.3-28.1                \n[103] Matrix_1.5-3                  permute_0.9-7                \n[105] cli_3.6.0                     adegraphics_1.0-17           \n[107] R.methodsS3_1.8.2             parallel_4.2.2               \n[109] metapod_1.6.0                 igraph_1.4.1                 \n[111] pkgconfig_2.0.3               rncl_0.8.7                   \n[113] sp_1.6-0                      xml2_1.3.3                   \n[115] vipor_0.4.5                   dqrng_0.3.0                  \n[117] XVector_0.38.0                digest_0.6.31                \n[119] vegan_2.6-4                   Biostrings_2.66.0            \n[121] rmarkdown_2.20                edgeR_3.40.2                 \n[123] DelayedMatrixStats_1.20.0     curl_5.0.0                   \n[125] shiny_1.7.4                   rjson_0.2.21                 \n[127] lifecycle_1.0.3               nlme_3.1-162                 \n[129] jsonlite_1.8.4                Rhdf5lib_1.20.0              \n[131] BiocNeighbors_1.16.0          seqinr_4.2-23                \n[133] viridisLite_0.4.1             limma_3.54.1                 \n[135] fansi_1.0.4                   pillar_1.8.1                 \n[137] lattice_0.20-45               KEGGREST_1.38.0              \n[139] fastmap_1.1.1                 httr_1.4.5                   \n[141] interactiveDisplayBase_1.36.0 glue_1.6.2                   \n[143] png_0.1-8                     BiocVersion_3.16.0           \n[145] bit_4.0.5                     class_7.3-21                 \n[147] stringi_1.7.12                HDF5Array_1.26.0             \n[149] blob_1.2.3                    BiocSingular_1.14.0          \n[151] AnnotationHub_3.6.0           latticeExtra_0.6-30          \n[153] memoise_2.0.1                 irlba_2.3.5.1                \n[155] e1071_1.7-13                  ape_5.7                      \n```\n:::\n:::\n\n\n# References\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}